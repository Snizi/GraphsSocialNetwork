"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Carousel = void 0;
const jsx_runtime_1 = require("react/jsx-runtime");
const react_1 = __importStar(require("react"));
const slide_1 = __importDefault(require("./slide"));
const announce_slide_1 = __importDefault(require("./announce-slide"));
const slider_list_1 = require("./slider-list");
const controls_1 = __importDefault(require("./controls"));
const default_carousel_props_1 = __importDefault(require("./default-carousel-props"));
const utils_1 = require("./utils");
const use_frame_height_1 = require("./hooks/use-frame-height");
const Carousel = (rawProps) => {
    /**
     * We need this cast because we want the component's properties to seem
     * optional to external users, but always-present for the internal
     * implementation.
     *
     * This cast is safe due to the `Carousel.defaultProps = defaultProps;`
     * statement below. That guarantees all the properties are present, since
     * `defaultProps` has type `InternalCarouselProps`.
     */
    const props = rawProps;
    const { adaptiveHeight, adaptiveHeightAnimation, afterSlide, animation, autoplay, autoplayInterval, autoplayReverse, beforeSlide, cellAlign, cellSpacing, children, className, disableAnimation, disableEdgeSwiping, dragging, dragThreshold: propsDragThreshold, enableKeyboardControls, frameAriaLabel, innerRef, keyCodeConfig, onDrag, onDragEnd, onDragStart, pauseOnHover, renderAnnounceSlideMessage, scrollMode, slideIndex, slidesToScroll: propsSlidesToScroll, slidesToShow, speed: propsSpeed, style, swiping, wrapAround, zoomScale } = props;
    const count = react_1.default.Children.count(children);
    const [currentSlide, setCurrentSlide] = (0, react_1.useState)(autoplayReverse ? count - slidesToShow : slideIndex);
    const [animationEnabled, setAnimationEnabled] = (0, react_1.useState)(false);
    const [pause, setPause] = (0, react_1.useState)(false);
    const [isDragging, setIsDragging] = (0, react_1.useState)(false);
    const [move, setMove] = (0, react_1.useState)(0);
    const [keyboardMove, setKeyboardMove] = (0, react_1.useState)(null);
    const carouselWidth = (0, react_1.useRef)(null);
    const focus = (0, react_1.useRef)(false);
    const prevMove = (0, react_1.useRef)(0);
    const carouselEl = (0, react_1.useRef)(null);
    const timer = (0, react_1.useRef)(null);
    const isMounted = (0, react_1.useRef)(true);
    const slidesToScroll = animation === 'fade' ? slidesToShow : propsSlidesToScroll;
    const dragThreshold = ((carouselWidth.current || 0) / slidesToShow) * propsDragThreshold;
    const [slide] = (0, utils_1.getIndexes)(currentSlide, currentSlide - slidesToScroll, count);
    (0, react_1.useEffect)(() => {
        isMounted.current = true;
        return () => {
            isMounted.current = false;
        };
    }, []);
    (0, react_1.useEffect)(() => {
        // disable img draggable attribute by default, this will improve the dragging
        document
            .querySelectorAll('.slider-list img')
            .forEach((el) => el.setAttribute('draggable', 'false'));
    }, []);
    const carouselRef = innerRef || carouselEl;
    const getNextIndex = (0, react_1.useCallback)((to) => {
        const index = to !== null && to !== void 0 ? to : currentSlide;
        if (index < 0) {
            return index + count;
        }
        if (index === count) {
            return 0;
        }
        return index;
    }, [count, currentSlide]);
    const moveSlide = (0, react_1.useCallback)((to) => {
        const nextIndex = getNextIndex(to);
        typeof to === 'number' && beforeSlide(slide, nextIndex);
        !disableAnimation && setAnimationEnabled(true);
        if (typeof to === 'number') {
            setCurrentSlide(to);
        }
        setTimeout(() => {
            if (!isMounted.current)
                return;
            typeof to === 'number' && afterSlide(nextIndex);
            !disableAnimation && setAnimationEnabled(false);
        }, !disableAnimation ? propsSpeed || 500 : 40); // if animation is disabled decrease the speed to 40
    }, [slide, afterSlide, beforeSlide, disableAnimation, getNextIndex, propsSpeed]);
    const nextSlide = (0, react_1.useCallback)(() => {
        if (wrapAround || currentSlide < count - propsSlidesToScroll) {
            const nextPosition = (0, utils_1.getNextMoveIndex)(scrollMode, wrapAround, currentSlide, count, propsSlidesToScroll, slidesToShow);
            moveSlide(nextPosition);
        }
    }, [
        count,
        currentSlide,
        moveSlide,
        propsSlidesToScroll,
        scrollMode,
        wrapAround,
        slidesToShow
    ]);
    const prevSlide = (0, react_1.useCallback)(() => {
        // boundary
        if (wrapAround || currentSlide > 0) {
            const prevPosition = (0, utils_1.getPrevMoveIndex)(scrollMode, wrapAround, currentSlide, propsSlidesToScroll);
            moveSlide(prevPosition);
        }
    }, [currentSlide, moveSlide, propsSlidesToScroll, scrollMode, wrapAround]);
    // When user changed the slideIndex property from outside.
    const prevMovedToSlideIndex = (0, react_1.useRef)(slideIndex);
    (0, react_1.useEffect)(() => {
        if (slideIndex !== prevMovedToSlideIndex.current && !autoplayReverse) {
            moveSlide(slideIndex);
            prevMovedToSlideIndex.current = slideIndex;
        }
    }, [slideIndex, currentSlide, autoplayReverse, moveSlide]);
    // Makes the carousel infinity when autoplay and wrapAround are enabled
    (0, react_1.useEffect)(() => {
        if (autoplay && !animationEnabled && wrapAround) {
            if (currentSlide > count) {
                setCurrentSlide(currentSlide - count);
                if (timer === null || timer === void 0 ? void 0 : timer.current) {
                    clearTimeout(timer.current);
                }
            }
            else if (currentSlide < 0) {
                setCurrentSlide(count - -currentSlide);
                if (timer === null || timer === void 0 ? void 0 : timer.current) {
                    clearTimeout(timer.current);
                }
            }
        }
    }, [animationEnabled, currentSlide, count, wrapAround, autoplay]);
    (0, react_1.useEffect)(() => {
        if (autoplay && !pause) {
            timer.current = setTimeout(() => {
                if (autoplayReverse) {
                    if (!wrapAround && currentSlide > 0) {
                        prevSlide();
                    }
                    else if (wrapAround) {
                        prevSlide();
                    }
                }
                else if (!wrapAround && currentSlide < count - slidesToShow) {
                    nextSlide();
                }
                else if (wrapAround) {
                    nextSlide();
                }
            }, autoplayInterval);
        }
        // Clear the timeout if user hover on carousel
        if (autoplay && pause && (timer === null || timer === void 0 ? void 0 : timer.current)) {
            clearTimeout(timer.current);
        }
        return () => {
            if (timer.current) {
                clearTimeout(timer.current);
            }
        };
    }, [
        currentSlide,
        slidesToShow,
        count,
        pause,
        autoplay,
        autoplayInterval,
        autoplayReverse,
        wrapAround,
        prevSlide,
        nextSlide
    ]);
    // Makes the carousel infinity when wrapAround is enabled, but autoplay is disabled
    (0, react_1.useEffect)(() => {
        let prevTimeout = null;
        let nextTimeout = null;
        if (wrapAround && !autoplay) {
            // if animation is disabled decrease the speed to 0
            const speed = !disableAnimation ? propsSpeed || 500 : 0;
            if (currentSlide <= -slidesToShow) {
                // prev
                prevTimeout = setTimeout(() => {
                    if (!isMounted.current)
                        return;
                    setCurrentSlide(count - -currentSlide);
                }, speed + 10);
            }
            else if (currentSlide >= count) {
                // next
                nextTimeout = setTimeout(() => {
                    if (!isMounted.current)
                        return;
                    setCurrentSlide(currentSlide - count);
                }, speed + 10);
            }
        }
        return function cleanup() {
            if (prevTimeout) {
                clearTimeout(prevTimeout);
            }
            if (nextTimeout) {
                clearTimeout(nextTimeout);
            }
        };
    }, [
        currentSlide,
        autoplay,
        wrapAround,
        disableAnimation,
        propsSpeed,
        slidesToShow,
        count
    ]);
    (0, react_1.useEffect)(() => {
        if (enableKeyboardControls && keyboardMove && focus.current) {
            switch (keyboardMove) {
                case 'nextSlide':
                    nextSlide();
                    break;
                case 'previousSlide':
                    prevSlide();
                    break;
                case 'firstSlide':
                    setCurrentSlide(0);
                    break;
                case 'lastSlide':
                    setCurrentSlide(count - slidesToShow);
                    break;
                case 'pause':
                    if (pause && autoplay) {
                        setPause(false);
                        break;
                    }
                    else if (autoplay) {
                        setPause(true);
                        break;
                    }
                    break;
            }
            setKeyboardMove(null);
        }
    }, [
        keyboardMove,
        enableKeyboardControls,
        count,
        slidesToShow,
        pause,
        autoplay,
        nextSlide,
        prevSlide
    ]);
    const onKeyPress = (0, react_1.useCallback)((e) => {
        var _a;
        if (enableKeyboardControls &&
            focus.current &&
            e.keyCode) {
            const keyConfig = keyCodeConfig;
            for (const func in keyConfig) {
                if ((_a = keyConfig[func]) === null || _a === void 0 ? void 0 : _a.includes(e.keyCode)) {
                    setKeyboardMove(func);
                }
            }
        }
    }, [enableKeyboardControls, keyCodeConfig]);
    (0, react_1.useEffect)(() => {
        if (carouselEl && carouselEl.current) {
            carouselWidth.current = carouselEl.current.offsetWidth;
        }
        else if (innerRef) {
            carouselWidth.current = innerRef.current.offsetWidth;
        }
        if (enableKeyboardControls) {
            (0, utils_1.addEvent)(document, 'keydown', onKeyPress);
        }
        return () => {
            (0, utils_1.removeEvent)(document, 'keydown', onKeyPress);
        };
    }, [enableKeyboardControls, innerRef, onKeyPress]);
    const handleDragEnd = (0, react_1.useCallback)((e) => {
        if (!dragging || !isDragging)
            return;
        setIsDragging(false);
        onDragEnd(e);
        if (Math.abs(move) <= dragThreshold) {
            moveSlide();
            setMove(0);
            prevMove.current = 0;
            return;
        }
        if (move > 0) {
            nextSlide();
        }
        else {
            prevSlide();
        }
        setMove(0);
        prevMove.current = 0;
    }, [
        dragThreshold,
        isDragging,
        move,
        moveSlide,
        nextSlide,
        onDragEnd,
        prevSlide,
        dragging
    ]);
    const onTouchStart = (0, react_1.useCallback)((e) => {
        if (!swiping) {
            return;
        }
        setIsDragging(true);
        onDragStart(e);
    }, [onDragStart, swiping]);
    const handlePointerMove = (0, react_1.useCallback)((m) => {
        if (!dragging || !isDragging)
            return;
        const moveValue = m * 0.75; // Friction
        const moveState = move + (moveValue - prevMove.current);
        // Exit drag early if passed threshold
        if (Math.abs(move) > dragThreshold) {
            handleDragEnd();
            return;
        }
        if (!wrapAround &&
            disableEdgeSwiping &&
            ((currentSlide <= 0 && moveState <= 0) ||
                (moveState > 0 && currentSlide >= count - slidesToShow))) {
            prevMove.current = moveValue;
            return;
        }
        if (prevMove.current !== 0) {
            setMove(moveState);
        }
        prevMove.current = moveValue;
    }, [
        count,
        currentSlide,
        disableEdgeSwiping,
        dragThreshold,
        isDragging,
        handleDragEnd,
        move,
        dragging,
        slidesToShow,
        wrapAround
    ]);
    const onTouchMove = (0, react_1.useCallback)((e) => {
        if (!dragging || !isDragging)
            return;
        onDragStart(e);
        const moveValue = ((carouselWidth === null || carouselWidth === void 0 ? void 0 : carouselWidth.current) || 0) - e.touches[0].pageX;
        handlePointerMove(moveValue);
    }, [dragging, isDragging, handlePointerMove, onDragStart]);
    const onMouseDown = (0, react_1.useCallback)((e) => {
        var _a;
        if (!dragging)
            return;
        (_a = carouselRef === null || carouselRef === void 0 ? void 0 : carouselRef.current) === null || _a === void 0 ? void 0 : _a.focus();
        setIsDragging(true);
        onDragStart(e);
    }, [carouselRef, dragging, onDragStart]);
    const onMouseMove = (0, react_1.useCallback)((e) => {
        var _a;
        if (!dragging || !isDragging)
            return;
        onDrag(e);
        const offsetX = e.clientX - (((_a = carouselRef.current) === null || _a === void 0 ? void 0 : _a.getBoundingClientRect().left) || 0);
        const moveValue = ((carouselWidth === null || carouselWidth === void 0 ? void 0 : carouselWidth.current) || 0) - offsetX;
        handlePointerMove(moveValue);
    }, [carouselRef, isDragging, handlePointerMove, onDrag, dragging]);
    const onMouseUp = (0, react_1.useCallback)((e) => {
        e === null || e === void 0 ? void 0 : e.preventDefault();
        handleDragEnd(e);
    }, [handleDragEnd]);
    const onMouseEnter = (0, react_1.useCallback)(() => {
        if (pauseOnHover) {
            setPause(true);
        }
    }, [pauseOnHover]);
    const onMouseLeave = (0, react_1.useCallback)(() => {
        if (pauseOnHover) {
            setPause(false);
        }
    }, [pauseOnHover]);
    const { frameHeight, handleVisibleSlideHeightChange, initializedAdaptiveHeight } = (0, use_frame_height_1.useFrameHeight)({
        adaptiveHeight,
        slidesToShow,
        numSlides: count
    });
    const renderSlides = (typeOfSlide) => {
        const slides = react_1.default.Children.map(children, (child, index) => {
            const isCurrentSlide = wrapAround
                ? currentSlide === index ||
                    currentSlide === index + count ||
                    currentSlide === index - count
                : currentSlide === index;
            return ((0, jsx_runtime_1.jsx)(slide_1.default, Object.assign({ count: count, currentSlide: currentSlide, index: index, isCurrentSlide: isCurrentSlide, typeOfSlide: typeOfSlide, wrapAround: wrapAround, cellSpacing: cellSpacing, animation: animation, slidesToShow: slidesToShow, speed: propsSpeed, zoomScale: zoomScale, cellAlign: cellAlign, onVisibleSlideHeightChange: handleVisibleSlideHeightChange, adaptiveHeight: adaptiveHeight, initializedAdaptiveHeight: initializedAdaptiveHeight }, { children: child }), `${typeOfSlide}-${index}`));
        });
        return slides;
    };
    return ((0, jsx_runtime_1.jsxs)("div", Object.assign({ className: 'slider-container', style: {
            position: 'relative'
        }, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave }, { children: [(0, jsx_runtime_1.jsx)(announce_slide_1.default, { ariaLive: autoplay && !pause ? 'off' : 'polite', message: renderAnnounceSlideMessage({
                    currentSlide: slide,
                    count
                }) }), (0, controls_1.default)(props, count, currentSlide, moveSlide, nextSlide, prevSlide, slidesToScroll), (0, jsx_runtime_1.jsx)("div", Object.assign({ className: ['slider-frame', className || ''].join(' ').trim(), style: Object.assign({ overflow: 'hidden', width: '100%', position: 'relative', outline: 'none', height: frameHeight, transition: adaptiveHeightAnimation
                        ? 'height 300ms ease-in-out'
                        : undefined, willChange: 'height' }, style), "aria-label": frameAriaLabel, role: "region", tabIndex: 0, onFocus: () => (focus.current = true), onBlur: () => (focus.current = false), ref: innerRef || carouselEl, onMouseUp: onMouseUp, onMouseDown: onMouseDown, onMouseMove: onMouseMove, onMouseLeave: onMouseUp, onTouchStart: onTouchStart, onTouchEnd: handleDragEnd, onTouchMove: onTouchMove }, { children: (0, jsx_runtime_1.jsxs)("div", Object.assign({ className: "slider-list", style: (0, slider_list_1.getSliderListStyles)(children, currentSlide, animationEnabled, slidesToShow, cellAlign, wrapAround, propsSpeed, move, animation) }, { children: [wrapAround ? renderSlides('prev-cloned') : null, renderSlides(), wrapAround ? renderSlides('next-cloned') : null] })) }))] })));
};
exports.Carousel = Carousel;
exports.Carousel.defaultProps = default_carousel_props_1.default;
exports.default = exports.Carousel;
//# sourceMappingURL=carousel.js.map